package chapter06;

// === 오버 라이딩 ===
// 자식 클래스가 부모 클래스에서 정의된 "메서드"를 자신의 상황에 맞게 "재정의"
// >> 상속관계에 있는 클래스들 사이에서 사용

// 1. 오버라이딩
// - 메서드의 시그니쳐(선언부)가 일치한다.
// >> 부모클래스에서 정의 된 메서드와 동일한 이름. 매개변수 구성을 가져야 한다.
// - 반환 타입은 같거나 자동 형 변환이 가능한 것이여야 한다.

// @override(어노테이션, 주석)
// : 오버라이딩 된 메서드임을 명시적으로 표시

// cf) 선언부
// 반환타입 메서드명(매개변수)

// 2. 부모클래스의 상속받은 메서드를 자식 클래스에서 다시 정의
// - 메서드의 이름, 매개변수를 일치, 바노하 타입은 같거나 형 변환 가능하게 작성
// - 메서드 위에 @override 어노스테이션을 작성

// 3. 오버라이딩을 사용하는 이유
// - 다형성 구현
// : 하나의 이름으로 여러 기능을 수행하는 코드 작성
// - 재사용성 확장성 향상
// : 기존 코드 변경 없이, 새로운 기능을 추가하거나 변경 가능

class AnimalClass {
	void sound() {
		System.out.println("동물이 소리를 냄.");
	}
}

class DogClass extends AnimalClass {
	// 어노스테이션 
	//: 코드에 메타데이터를 제공하는 방법
	
	// @Override 현재 메서드가 부모 클래스의 메서드를 오버라이딩 한다는 것을 명시
	@Override
	void sound() {
		System.out.println("개가 멍멍");
	}
}

class CatClass extends AnimalClass {

	@Override
	void sound() {
		System.out.println("애옹");
	}
}

public class Overriding {
	public static void main(String[] args) {
		DogClass newdog = new DogClass();
		newdog.sound();
		
		CatClass newcat = new CatClass();
		newcat.sound();
		
		// 부모로부터 상속박은 속성이나 메서드를 확장하는 개념
		// : 해당 상태나 동작을 반드지 가지지만 삳속받는 클래스마다 차이를 두고 싶을 때
		
		
		// == 오버로딩 vs 오버라이딩 ==
		// : 모두 메서드의 이름을 재사용하는 방법 (다형성)
		
		// 1) 오버로딩
		// - 같은  클래스 내에서 같은 이름을 사진 메서드응 여러개 정의
		// - 메서드 명의 동일. 매새변수의 타입, 개수, 순서 중 적어도 하나 이상은 달라야 함
		// - 메서드 동작을 다양한 상황에 맞게 조정
		
		
		// 2) 오버라이딩
		// - 상속 관계에 있는 클래스에서 사용
		// - 메서드의 시그니처가 같아야함
		// - 메서드의 동작을 변경하거나 확장
		// + @override 어노테이션을 사용 >> 컨파일러에게 전달
	}
}
